#!/usr/bin/env node\n\nimport fs from 'fs';\nimport path from 'path';\nimport { execSync } from 'child_process';\nimport config from '../config/index.js';\nimport { Database } from 'better-sqlite3';\nimport MigrationManager from '../migrations/index.js';\nimport SystemMonitoringService from '../services/SystemMonitoringService';\nimport FeatureFlagService from '../services/FeatureFlagService.js';\n\n// Deployment configuration\ninterface DeploymentConfig {\n  environment: string;\n  skipMigrations: boolean;\n  skipBackup: boolean;\n  skipHealthCheck: boolean;\n  dryRun: boolean;\n  verbose: boolean;\n}\n\nclass DeploymentManager {\n  private config: DeploymentConfig;\n  private startTime: number;\n\n  constructor(deployConfig: DeploymentConfig) {\n    this.config = deployConfig;\n    this.startTime = Date.now();\n  }\n\n  public async deploy(): Promise<void> {\n    console.log('üöÄ Starting RiderPro Route Tracking deployment...');\n    console.log(`Environment: ${this.config.environment}`);\n    console.log(`Dry run: ${this.config.dryRun ? 'Yes' : 'No'}`);\n    console.log('=' .repeat(50));\n\n    try {\n      // Pre-deployment checks\n      await this.preDeploymentChecks();\n\n      // Create backup if not skipped\n      if (!this.config.skipBackup) {\n        await this.createBackup();\n      }\n\n      // Run database migrations\n      if (!this.config.skipMigrations) {\n        await this.runMigrations();\n      }\n\n      // Initialize services\n      await this.initializeServices();\n\n      // Post-deployment validation\n      if (!this.config.skipHealthCheck) {\n        await this.performHealthCheck();\n      }\n\n      // Generate deployment report\n      await this.generateDeploymentReport();\n\n      const duration = Math.round((Date.now() - this.startTime) / 1000);\n      console.log('\\n‚úÖ Deployment completed successfully!');\n      console.log(`Total time: ${duration}s`);\n\n    } catch (error) {\n      console.error('\\n‚ùå Deployment failed:', error);\n      \n      // Attempt rollback if not dry run\n      if (!this.config.dryRun) {\n        console.log('\\nüîÑ Attempting rollback...');\n        await this.rollback();\n      }\n      \n      process.exit(1);\n    }\n  }\n\n  private async preDeploymentChecks(): Promise<void> {\n    console.log('\\nüìã Running pre-deployment checks...');\n\n    // Check Node.js version\n    const nodeVersion = process.version;\n    console.log(`Node.js version: ${nodeVersion}`);\n    \n    if (parseInt(nodeVersion.slice(1)) < 18) {\n      throw new Error('Node.js version 18 or higher is required');\n    }\n\n    // Check environment variables\n    this.validateEnvironmentVariables();\n\n    // Check disk space\n    await this.checkDiskSpace();\n\n    // Check database accessibility\n    await this.checkDatabaseAccess();\n\n    // Check required directories\n    this.ensureDirectories();\n\n    console.log('‚úÖ Pre-deployment checks passed');\n  }\n\n  private validateEnvironmentVariables(): void {\n    const required = [\n      'NODE_ENV',\n      'PORT'\n    ];\n\n    if (config.environment === 'production') {\n      required.push('JWT_SECRET');\n    }\n\n    const missing = required.filter(env => !process.env[env]);\n    if (missing.length > 0) {\n      throw new Error(`Missing required environment variables: ${missing.join(', ')}`);\n    }\n\n    console.log('‚úÖ Environment variables validated');\n  }\n\n  private async checkDiskSpace(): Promise<void> {\n    try {\n      const stats = fs.statSync('.');\n      // In a real implementation, you'd check actual disk space\n      console.log('‚úÖ Disk space check passed');\n    } catch (error) {\n      throw new Error('Failed to check disk space');\n    }\n  }\n\n  private async checkDatabaseAccess(): Promise<void> {\n    try {\n      if (config.database.path !== ':memory:' && !fs.existsSync(path.dirname(config.database.path))) {\n        fs.mkdirSync(path.dirname(config.database.path), { recursive: true });\n      }\n      console.log('‚úÖ Database access check passed');\n    } catch (error) {\n      throw new Error(`Database access check failed: ${error}`);\n    }\n  }\n\n  private ensureDirectories(): void {\n    const directories = [\n      config.uploads.storageDir,\n      './logs',\n      './backups'\n    ];\n\n    directories.forEach(dir => {\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n        console.log(`Created directory: ${dir}`);\n      }\n    });\n\n    console.log('‚úÖ Required directories ensured');\n  }\n\n  private async createBackup(): Promise<void> {\n    console.log('\\nüíæ Creating database backup...');\n\n    if (this.config.dryRun) {\n      console.log('üîç [DRY RUN] Would create database backup');\n      return;\n    }\n\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const backupDir = './backups';\n      const backupFile = path.join(backupDir, `riderpro-${timestamp}.db`);\n\n      if (config.database.path !== ':memory:' && fs.existsSync(config.database.path)) {\n        fs.copyFileSync(config.database.path, backupFile);\n        console.log(`‚úÖ Database backup created: ${backupFile}`);\n\n        // Keep only last 10 backups\n        this.cleanupOldBackups(backupDir, 10);\n      } else {\n        console.log('‚ÑπÔ∏è No existing database to backup');\n      }\n    } catch (error) {\n      throw new Error(`Backup creation failed: ${error}`);\n    }\n  }\n\n  private cleanupOldBackups(backupDir: string, keepCount: number): void {\n    try {\n      const backups = fs.readdirSync(backupDir)\n        .filter(file => file.startsWith('riderpro-') && file.endsWith('.db'))\n        .map(file => ({\n          name: file,\n          path: path.join(backupDir, file),\n          mtime: fs.statSync(path.join(backupDir, file)).mtime\n        }))\n        .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());\n\n      if (backups.length > keepCount) {\n        const toDelete = backups.slice(keepCount);\n        toDelete.forEach(backup => {\n          fs.unlinkSync(backup.path);\n          console.log(`Deleted old backup: ${backup.name}`);\n        });\n      }\n    } catch (error) {\n      console.warn('Failed to cleanup old backups:', error);\n    }\n  }\n\n  private async runMigrations(): Promise<void> {\n    console.log('\\nüîÑ Running database migrations...');\n\n    if (this.config.dryRun) {\n      console.log('üîç [DRY RUN] Would run database migrations');\n      return;\n    }\n\n    try {\n      // Import Database dynamically to avoid circular dependencies\n      const { default: Database } = await import('better-sqlite3');\n      const db = new Database(config.database.path);\n      \n      // Configure database\n      db.pragma('journal_mode = WAL');\n      db.pragma('synchronous = NORMAL');\n      db.pragma('cache_size = 10000');\n      db.pragma('temp_store = MEMORY');\n\n      const migrationManager = new MigrationManager(db);\n      const result = await migrationManager.runMigrations();\n\n      if (result.success) {\n        console.log(`‚úÖ ${result.executed} migrations executed successfully`);\n        \n        // Initialize default data\n        migrationManager.initializeDefaultData();\n      } else {\n        throw new Error(`Migration failed: ${result.errors.join(', ')}`);\n      }\n\n      db.close();\n    } catch (error) {\n      throw new Error(`Migration execution failed: ${error}`);\n    }\n  }\n\n  private async initializeServices(): Promise<void> {\n    console.log('\\n‚öôÔ∏è Initializing services...');\n\n    if (this.config.dryRun) {\n      console.log('üîç [DRY RUN] Would initialize services');\n      return;\n    }\n\n    try {\n      // Initialize feature flags with default values\n      const { default: Database } = await import('better-sqlite3');\n      const db = new Database(config.database.path);\n      \n      const featureFlagService = FeatureFlagService.getInstance(db);\n      \n      // Ensure all feature flags exist\n      const defaultFlags = [\n        { name: 'route_tracking', enabled: config.featureFlags.routeTracking, description: 'Core route tracking functionality' },\n        { name: 'live_tracking', enabled: config.featureFlags.liveTracking, description: 'Real-time live tracking dashboard' },\n        { name: 'route_analytics', enabled: config.featureFlags.routeAnalytics, description: 'Route analytics and reporting' },\n        { name: 'route_visualization', enabled: config.featureFlags.routeVisualization, description: 'Route visualization and playback' },\n        { name: 'route_optimization', enabled: config.featureFlags.routeOptimization, description: 'Route optimization suggestions' },\n        { name: 'mobile_optimization', enabled: config.featureFlags.mobileOptimization, description: 'Mobile-specific optimizations' },\n        { name: 'advanced_analytics', enabled: config.featureFlags.advancedAnalytics, description: 'Advanced analytics features' },\n        { name: 'data_export', enabled: config.featureFlags.dataExport, description: 'Data export functionality' },\n        { name: 'audit_logs', enabled: config.featureFlags.auditLogs, description: 'Audit logging system' },\n        { name: 'privacy_controls', enabled: config.featureFlags.privacyControls, description: 'Privacy and consent controls' },\n        { name: 'database_optimization', enabled: config.featureFlags.databaseOptimization, description: 'Database optimization features' },\n        { name: 'performance_monitoring', enabled: config.featureFlags.performanceMonitoring, description: 'Performance monitoring and alerting' }\n      ];\n\n      defaultFlags.forEach(flag => {\n        featureFlagService.createFlag(flag, 'deployment');\n      });\n\n      db.close();\n      console.log('‚úÖ Services initialized');\n    } catch (error) {\n      throw new Error(`Service initialization failed: ${error}`);\n    }\n  }\n\n  private async performHealthCheck(): Promise<void> {\n    console.log('\\nüè• Performing health check...');\n\n    if (this.config.dryRun) {\n      console.log('üîç [DRY RUN] Would perform health check');\n      return;\n    }\n\n    try {\n      const { default: Database } = await import('better-sqlite3');\n      const db = new Database(config.database.path);\n      \n      const monitoringService = MonitoringService.getInstance(db, config.monitoring);\n      const healthResult = await monitoringService.performHealthCheck();\n\n      console.log(`Health Status: ${healthResult.status}`);\n      console.log(`Services: Database(${healthResult.services.database}), Auth(${healthResult.services.authentication}), Routes(${healthResult.services.routeTracking})`);\n      \n      if (healthResult.status === 'critical') {\n        throw new Error('Health check failed - system is in critical state');\n      }\n\n      if (healthResult.alerts.length > 0) {\n        console.log(`‚ö†Ô∏è ${healthResult.alerts.length} alerts detected`);\n        healthResult.alerts.forEach(alert => {\n          console.log(`  - ${alert.type.toUpperCase()}: ${alert.title}`);\n        });\n      }\n\n      db.close();\n      console.log('‚úÖ Health check passed');\n    } catch (error) {\n      throw new Error(`Health check failed: ${error}`);\n    }\n  }\n\n  private async generateDeploymentReport(): Promise<void> {\n    console.log('\\nüìä Generating deployment report...');\n\n    const report = {\n      deployment: {\n        timestamp: new Date().toISOString(),\n        environment: this.config.environment,\n        version: process.env.npm_package_version || '1.0.0',\n        duration: Math.round((Date.now() - this.startTime) / 1000),\n        dryRun: this.config.dryRun\n      },\n      configuration: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        architecture: process.arch,\n        routeTrackingEnabled: config.routeTracking.enabled,\n        monitoringEnabled: config.monitoring.enabled,\n        databasePath: config.database.path\n      },\n      features: Object.entries(config.featureFlags)\n        .filter(([, enabled]) => enabled)\n        .map(([feature]) => feature)\n    };\n\n    const reportPath = `./logs/deployment-${new Date().toISOString().split('T')[0]}.json`;\n    \n    if (!this.config.dryRun) {\n      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\n      console.log(`‚úÖ Deployment report saved: ${reportPath}`);\n    } else {\n      console.log('üîç [DRY RUN] Would save deployment report');\n      console.log(JSON.stringify(report, null, 2));\n    }\n  }\n\n  private async rollback(): Promise<void> {\n    try {\n      console.log('üîÑ Rolling back deployment...');\n      \n      // Find latest backup\n      const backupDir = './backups';\n      if (fs.existsSync(backupDir)) {\n        const backups = fs.readdirSync(backupDir)\n          .filter(file => file.startsWith('riderpro-') && file.endsWith('.db'))\n          .map(file => ({\n            name: file,\n            path: path.join(backupDir, file),\n            mtime: fs.statSync(path.join(backupDir, file)).mtime\n          }))\n          .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());\n\n        if (backups.length > 0) {\n          const latestBackup = backups[0];\n          fs.copyFileSync(latestBackup.path, config.database.path);\n          console.log(`‚úÖ Database restored from backup: ${latestBackup.name}`);\n        }\n      }\n      \n      console.log('‚úÖ Rollback completed');\n    } catch (error) {\n      console.error('‚ùå Rollback failed:', error);\n    }\n  }\n}\n\n// CLI interface\nfunction parseArgs(): DeploymentConfig {\n  const args = process.argv.slice(2);\n  const config: DeploymentConfig = {\n    environment: process.env.NODE_ENV || 'development',\n    skipMigrations: false,\n    skipBackup: false,\n    skipHealthCheck: false,\n    dryRun: false,\n    verbose: false\n  };\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    switch (arg) {\n      case '--environment':\n      case '-e':\n        config.environment = args[++i];\n        break;\n      case '--skip-migrations':\n        config.skipMigrations = true;\n        break;\n      case '--skip-backup':\n        config.skipBackup = true;\n        break;\n      case '--skip-health-check':\n        config.skipHealthCheck = true;\n        break;\n      case '--dry-run':\n        config.dryRun = true;\n        break;\n      case '--verbose':\n      case '-v':\n        config.verbose = true;\n        break;\n      case '--help':\n      case '-h':\n        printHelp();\n        process.exit(0);\n        break;\n      default:\n        console.error(`Unknown argument: ${arg}`);\n        process.exit(1);\n    }\n  }\n\n  return config;\n}\n\nfunction printHelp(): void {\n  console.log(`\nRiderPro Route Tracking Deployment Script\n\nUsage: npm run deploy [options]\n\nOptions:\n  -e, --environment <env>    Target environment (development, staging, production)\n  --skip-migrations          Skip database migrations\n  --skip-backup             Skip database backup\n  --skip-health-check       Skip post-deployment health check\n  --dry-run                 Show what would be done without making changes\n  -v, --verbose             Enable verbose logging\n  -h, --help                Show this help message\n\nExamples:\n  npm run deploy                           # Deploy to current environment\n  npm run deploy -- --environment production  # Deploy to production\n  npm run deploy -- --dry-run             # Preview deployment changes\n  npm run deploy -- --skip-backup         # Deploy without creating backup\n`);\n}\n\n// Main execution\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const deployConfig = parseArgs();\n  const deployment = new DeploymentManager(deployConfig);\n  \n  deployment.deploy().catch(error => {\n    console.error('Deployment failed:', error);\n    process.exit(1);\n  });\n}\n\nexport default DeploymentManager;\n"